import { Component, Element, Prop } from '@stencil/core';
import { GeoJSON } from 'geojson';

import { getStore } from '../../utils/store';

import { isvalidURL } from '../../utils/checkUtils';

import { Map as MaplibreglMap, GeoJSONSourceSpecification, VectorSourceSpecification, RasterSourceSpecification } from 'maplibre-gl';

import { bbox } from '@turf/bbox'
import { KortxyzMaplibre } from '../kortxyz-maplibre/kortxyz-maplibre';

/**
 ## Intro
Webcomponent load a new source into a kortxyz-maplibre component. An id is autogenerated if not present.

## Example
* Load a geojson source
```html
<kortxyz-maplibre>
    <kortxyz-maplibre-source
        id="afstemningsomraader"
        data="https://api.dataforsyningen.dk/afstemningsomraader?kommunekode=183&&format=geojson"
    ></kortxyz-maplibre-source>
<kortxyz-maplibre>

```

* Load a raster source
```html
<kortxyz-maplibre>
    <kortxyz-maplibre-source
        id="orto_foraar_webm"
        type="raster"
        tilesize="256" 
        maxzoom="20" 
        tiles="https://api.dataforsyningen.dk/orto_foraar_webm_DAF?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=orto_foraar_webm&STYLE=default&FORMAT=image%2Fjpeg&TILEMATRIXSET=DFD_GoogleMapsCompatible&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&token=<INSERT TOKEN>">
    ></kortxyz-maplibre-source>
<kortxyz-maplibre>

```
 */
@Component({
  tag: 'kortxyz-maplibre-source',
  shadow: true,
})

export class KortxyzMaplibreSource {
  @Element() el: HTMLElement;
  private map: MaplibreglMap;
  private loading: boolean = true;
  private randomColor = () => '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');

  /** Source identification */
  @Prop() sourceid  = Math.random().toString(36).substring(2,7);

  /** Type of source. */
  @Prop() type: 'vector' | 'geojson' | 'raster' = 'geojson';

  /** URL to the geojson source. */
  @Prop() data: string;
  /** Datastore reference. */
  @Prop() store: string;

  /** Url to the tilesource. e.g. https://demotiles.maplibre.org/tiles/{z}/{x}/{y}.pbf */
  @Prop() tiles: string;

  /** Size of the tiles in px. */
  @Prop() tilesize: number = 512;

  /** Max zoom-level to fetch tiles. z-parameter */
  @Prop() maxzoom: number = 14;

  /** fit mapbounds to geojsonbounds  */
  @Prop() fit: boolean = false;

  /** add a layer without specifing it. If no kortxyz-maplibre-layer children, it is automatically set to true.*/
  @Prop({mutable:true}) autolayers: boolean = false;

  private source: any = [];

  getMapboxType = geojsonGeomType => ({
    Point: 'circle',
    MultiPoint: 'circle',
    LineString: 'line',
    MultiLineString: 'line',
    Polygon: 'fill',
    MultiPolygon: 'fill',
    GeometryCollection: 'fill'
  }[geojsonGeomType]);

  getSourceObject = () => {
    if (this.type == 'geojson') {
      let SourceSpecification: GeoJSONSourceSpecification = {
        'type': this.type,
        'data': {
          'type': 'FeatureCollection',
          'features': []
        }
      }
      return SourceSpecification
    }

    else if (this.type == 'vector' || this.type == 'raster') {
      let SourceSpecification: VectorSourceSpecification | RasterSourceSpecification = {
        'type': this.type,
        'tiles': [this.tiles],
        'maxzoom': this.maxzoom,
        'tileSize': this.tilesize
      }
      return SourceSpecification
    }
  }

  updateGeojson = async (geojson) => {
    if (this.autolayers) {
      const geomTypeMap = geojson.features.reduce((acc, f) => ((acc[f.geometry.type] = (acc[f.geometry.type] || 0) + 1), acc), {});
      const geomTypes = Object.keys(geomTypeMap).sort((a, b) => geomTypeMap[b] - geomTypeMap[a]);
      geomTypes.forEach((geomType) => {
        const mapboxType = this.getMapboxType(geomType);

        if (this.map.getLayer(this.sourceid+"-"+geomType)) this.map.removeLayer(this.sourceid+"-"+geomType);

        let layerEl = document.createElement("kortxyz-maplibre-layer");
        layerEl.layerid = this.sourceid+"-"+geomType;
        layerEl.setAttribute("type", mapboxType);
        layerEl.setAttribute("paint", `{"${mapboxType}-color":"${this.randomColor()}","${mapboxType}-opacity":0.8}`);
        layerEl.setAttribute("popup", "");

        this.el.appendChild(layerEl)
      })
    }

    this.source.setData(geojson)
    
    if (this.fit) {
      const bounds: any = bbox(geojson);
      this.map.fitBounds(bounds, {
        animate: false,
        padding: 100,
        maxZoom: 16
      })
    }

  }

  addSource = async () => {
    this.map.addSource(this.sourceid, this.getSourceObject())
    this.source = this.map.getSource(this.sourceid)

    if (this.type == "geojson") {
        if (this.store) {
          while (this.loading) {
            const datastore = getStore(this.store);
            if (datastore == undefined) await new Promise(r => setTimeout(r, 200));
            else {
              this.updateGeojson(datastore.get("data"))
              datastore.onChange("data", (e: GeoJSON) => this.updateGeojson(e))
              this.loading = false;
            }
          }
        }
        else if (isvalidURL(this.data)) {
          const res = await fetch(this.data)
          const geojson = await res.json();
          this.updateGeojson(geojson)
        }
    }
    else if (this.type == "raster" && this.autolayers) {
      let layerEl = document.createElement("kortxyz-maplibre-layer");
          layerEl.id = this.sourceid+"-raster";
          layerEl.setAttribute("type", "raster");
      this.el.appendChild(layerEl)
    }
  }

  waitForStyleLoad = async () =>{
    if (this.map.loaded()) return;
    else await new Promise<void>(resolve => this.map.once('style.load', () => resolve()));
  }

  async componentWillLoad() {
    this.map = (this.el.parentElement as unknown as KortxyzMaplibre).map;
    
    if(this.el.children.length == 0) this.autolayers = true;
    
    await this.waitForStyleLoad();
    this.addSource();
    
  }



}
